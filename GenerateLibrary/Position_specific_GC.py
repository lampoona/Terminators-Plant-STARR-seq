#Sayeh Gorjifard
#Feburary 4th 2022
#script takes a position x nucleotide count file generated by oligo_frequency.py
#script outputs k number of randomly generated DNA sequences that recapitulate the observed oligo_frequency table. read out to a file
#example command: python3 Position_specific_GC.py foo_oligo_frequency_table.txt 1000 > foo_Positional_random.fa 

import sys
import string
import re
import pandas as pd
import csv 
import numpy as np
import os
import random 
from random import choice

random.seed(42)
#read in the oligo_frequency file generated by oligo_frequency.py. Please remove the header of that file before: sed '1d' <filename>_oligo_frequency_table.txt
file = sys.argv[1]

how_many = int(sys.argv[2])

base=os.path.basename(file)

#make dataframe from count table
#df = pd.read_csv(file, sep='\t', comment='t',header=[0])
df = pd.read_csv(file, sep='\t',header=[0])

header = ['Position', 'A_count', 'T_count' ,'G_count','C_count']

df.columns = header[:len(df.columns)]

#get sum of A,T,G,C count and calculate frequency of each letter as a new column
column_names = ['A_count', 'T_count' ,'G_count','C_count']
df['sum']= df[column_names].sum(axis=1)

#calculate frequency
df['A']=df['A_count']/df['sum']
df['T']=df['T_count']/df['sum']
df['G']=df['G_count']/df['sum']
df['C']=df['C_count']/df['sum']

#subset df to only the frequences
frequency = df[['A','T','G','C']]

#create an empty list for storing new sequences
data=[]

#for every row in the frequency table 
for row in df.itertuples():
	#get the index number
	index = row.Index
	#grab the row matching the frequences at that position 
	freq=frequency.iloc[index,:].tolist()
	#return a list of sequences for that position  from the unique frequency values of each. k is the number of sequences you want
	composition = random.choices( population=['A','T','G','C'], weights=freq, k=how_many*3)
	#add each sequence to data
	data.append(composition)

#turn the data list of strings into a numpy array and then transpose such that each row is now a column (since each row is all possible letters at htat position)
#turn data into a numpy array to transpose 
df1 = np.array(data)
df2=df1.transpose()

#concatenate the transposed dataframe row-wise 
Final_list = [''.join(x) for x in df2]

dfname=str(os.path.splitext(base)[0]).split('_')
#value = my_string.split(‘0’)

def check_for_RE(sequence): 
	testBool = False 
	regex = r"(G|^)AGAC(C|G)"
	regex2= r"(G|C|^)GTCTC"
	Test1 = bool(re.search(regex, sequence))
	Test2 = bool(re.search(regex2, sequence))
	if (Test1 == True):
		testBool = True
	elif (Test2 == True):
		testBool = True
	else: 
		testBool = False
	return testBool

n=0
for i,row in enumerate(Final_list):
	if (check_for_RE(row)==False and n<how_many):
		print(">" + dfname[0] + dfname[1] +"_Positional_random_" + str(i+1))
		print(row)
		n+=1












